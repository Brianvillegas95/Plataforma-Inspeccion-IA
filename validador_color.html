<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Validador de Color IA (Área) - Grupo Azor</title>
    <link rel="stylesheet" href="css/estilos.css">
    <link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.0.0-beta3/css/all.min.css">
    <script src="https://cdnjs.cloudflare.com/ajax/libs/chroma-js/2.4.2/chroma.min.js"></script>
    <script src="deltae.js"></script> 
</head>
<body class="color-validator-body">
    <div class="app-container">
        <header class="app-header">
            <div class="logo-container">
                <img src="imagenes/Logo azor.png" alt="Logo Grupo Azor" class="logo">
                <h1>Inspección de Calidad <span class="ia-badge">IA</span></h1>
            </div>
            <nav class="main-nav">
                <ul>
                    <li class="dropdown">
                        <a href="index.html" class="dropdown-toggle">Inicio</a>
                    </li>
                    <li class="dropdown">
                        <a href="#" class="dropdown-toggle active" data-area="Herramientas IA">Herramientas IA <i class="fas fa-angle-down nav-arrow"></i></a>
                        <ul class="dropdown-menu">
                            <li><a href="inspeccion_blister.html">Inspección Blíster</a></li>
                            <li><a href="validador_color.html" class="active">Validador de Color</a></li>
                        </ul>
                    </li>
                </ul>
            </nav>
        </header>

        <main class="main-content">
            <section class="tool-section color-validator-tool">
                <div class="section-header">
                    <i class="fas fa-palette feature-icon"></i>
                    <h2>Estación Digital de Validación de Color</h2>
                    <p id="main-instruction-text" style="font-weight: bold; color: #007bff;">Cargando cámara con ajustes predefinidos.</p>
                </div>

                <div class="color-validator-grid">
                    <div class="color-capture-panel">
                        <h3 class="panel-title-sub"><i class="fas fa-camera"></i> 1. Captura de Imagen</h3>
                        <div id="color-webcam-container" class="webcam-view">
                            <video id="color-video-feed" playsinline autoplay muted></video>
                            <p id="webcam-loading-prompt">Activando cámara...</p>
                        </div>
                        <canvas id="color-capture-canvas" style="display:none;"></canvas> 
                        <canvas id="calibration-helper-canvas" style="display:none;"></canvas>
                        <button id="capture-color-btn" class="button primary-action full-width-button">
                            <i class="fas fa-camera-retro"></i> Capturar Imagen
                        </button>
                        <input type="file" id="select-image-input" accept="image/*" style="display:none;">
                        <button id="select-image-btn" class="button secondary-action full-width-button" style="margin-top: 10px;">
                            <i class="fas fa-folder-open"></i> Seleccionar Imagen de Biblioteca
                        </button>
                        <div class="color-picker-instructions">
                            <p id="instruction-text" style="color: #212529; font-weight:bold;">Capture una imagen y dibuje un recuadro para seleccionar el área de color.</p>
                        </div>
                    </div>

                    <div class="color-analysis-panel">
                        <h3 class="panel-title-sub"><i class="fas fa-crop-alt"></i> 2. Área de Muestra y Estándar</h3>
                        <div class="captured-image-area">
                            <canvas id="display-captured-image-canvas" class="captured-image-canvas"></canvas> 
                            <p id="capture-prompt">Esperando imagen capturada...</p>
                        </div>
                        
                        <div class="form-group">
                            <label for="standard-color-select">Seleccione Color Estándar Azor:</label>
                            <select id="standard-color-select" name="standard-color-select">
                                <option value="">-- Elija un estándar --</option>
                            </select>
                        </div>
                        <button id="compare-colors-btn" class="button secondary-action full-width-button" disabled>
                            <i class="fas fa-exchange-alt"></i> Comparar Colores
                        </button>
                    </div>

                    <div class="color-results-panel">
                        <h3 class="panel-title-sub"><i class="fas fa-tachometer-alt"></i> 3. Resultados</h3>
                        <div class="color-comparison-display">
                            <div class="color-box-container">
                                <p>Color de Muestra (Promedio):</p>
                                <div id="captured-color-display" class="color-display-box"></div>
                                <span id="captured-color-values" class="color-value-text">-</span>
                            </div>
                            <div class="color-box-container">
                                <p>Color Estándar:</p>
                                <div id="standard-color-display" class="color-display-box"></div>
                                <span id="standard-color-values" class="color-value-text">-</span>
                            </div>
                        </div>
                        <div class="delta-e-result">
                            <h4>Diferencia de Color (ΔE*<sub_00</sub>):</h4>
                            <p id="delta-e-value" class="delta-e-value-text">-</p>
                            <div class="tolerance-bar-container">
                                <div id="tolerance-bar" class="tolerance-bar-fill"></div>
                            </div>
                            <p id="tolerance-status" class="tolerance-status-text">-</p>
                        </div>
                         <p id="color-result-note" class="note" style="margin-top:10px;"></p>
                    </div>
                </div> 
            </section>
        </main>

        <footer class="app-footer">
            &copy; <span id="currentYearColorValidator"></span> Grupo Azor México. Todos los derechos reservados.
        </footer>
    </div>

    <script type="text/javascript">
        if(document.getElementById('currentYearColorValidator')) {
            document.getElementById('currentYearColorValidator').textContent = new Date().getFullYear();
        }

        document.addEventListener('DOMContentLoaded', () => {
            console.log("DEBUG: Inicio DOMContentLoaded.");
            
            const videoElement = document.getElementById('color-video-feed');
            const webcamLoadingPrompt = document.getElementById('webcam-loading-prompt');
            const captureButton = document.getElementById('capture-color-btn');
            const selectImageBtn = document.getElementById('select-image-btn');
            const standardColorSelect = document.getElementById('standard-color-select');
            const compareButton = document.getElementById('compare-colors-btn');
            const instructionTextEl = document.getElementById('instruction-text');
            const mainInstructionTextEl = document.getElementById('main-instruction-text');


            const displayCanvas = document.getElementById('display-captured-image-canvas');
            const displayCtx = displayCanvas ? displayCanvas.getContext('2d', { willReadFrequently: true }) : null;
            const captureCanvas = document.getElementById('color-capture-canvas'); 
            const captureCtx = captureCanvas ? captureCanvas.getContext('2d', { willReadFrequently: true }) : null;
            // calibrationHelperCanvas y calibrationHelperCtx ya no se usan, pero se mantienen definidos para evitar errores si el HTML aún los referencia
            const calibrationHelperCanvas = document.getElementById('calibration-helper-canvas'); 
            const calibrationHelperCtx = calibrationHelperCanvas ? calibrationHelperCanvas.getContext('2d', { willReadFrequently: true }) : null; 

            const capturePrompt = document.getElementById('capture-prompt');
            
            const capturedColorDisplay = document.getElementById('captured-color-display');
            const capturedColorValuesEl = document.getElementById('captured-color-values');
            const standardColorDisplay = document.getElementById('standard-color-display');
            const standardColorValuesEl = document.getElementById('standard-color-values');
            const deltaEValueEl = document.getElementById('delta-e-value');
            const toleranceBar = document.getElementById('tolerance-bar');
            const toleranceStatusEl = document.getElementById('tolerance-status'); 
            const colorResultNoteEl = document.getElementById('color-result-note');
            const fileInput = document.getElementById('select-image-input');

            let stream = null;
            let pickedColorRGB = null; 
            let currentStandardColorData = null;
            let imageIsCaptured = false; 
            let isDrawingSelection = false;
            let selectionRect = { startX: 0, startY: 0, currentX: 0, currentY: 0, width: 0, height: 0 };
            let videoTrack = null; 
            let cameraCapabilities = {}; 
            // isCameraCalibrated ya no es necesaria, siempre se considera calibrada al iniciar
            let isCameraReady = false; // Nueva bandera para indicar que la cámara está lista y con ajustes aplicados

            const coloresEstandarAzor = {
"3001P": { nombre: "114.3001 BLANCO EN POLIPRO (USAR FONDO NEGRO)", hex: "#BBBABC", lab: { L: 75.6, a: 0.7, b: -0.9 } },
"3001N": { nombre: "114.3001 BLANCO EN NYLON (USAR FONDO NEGRO)", hex: "#C2BFBF", lab: { L: 77.6, a: 1, b: 0.4 } },
"3002": { nombre: "114.3002 GRIS CLARO", hex: "#757781", lab: { L: 50.2, a: 1.4, b: -5.7 } },
"3003": { nombre: "114.3003 PLATA", hex: "#959498", lab: { L: 61.5, a: 1.1, b: -2 } },
"3005": { nombre: "114.3005 AMARILLO CANARIO", hex: "#DAB639", lab: { L: 75.2, a: 0.4, b: 64.7 } },
"3011P": { nombre: "114.3011 NEGRO (POLIPRO)", hex: "#151517", lab: { L: 6.8, a: 0.5, b: -1.3 } },
"3011N": { nombre: "114.3011 NEGRO (NYLON)", hex: "#181719", lab: { L: 7.9, a: 1, b: -1.2 } },
"3012": { nombre: "114.3012 GRIS OBSCURO", hex: "#313238", lab: { L: 20.9, a: 1, b: -3.9 } },
"3015": { nombre: "114.3015 NEGRO HUMO TRANSLUCIDO (SAN)", hex: "#574C4D", lab: { L: 33.4, a: 4.8, b: 1.1 } },
"3020": { nombre: "114.3020 ROJO TRANSLUCIDO (SAN)", hex: "#7F0D16", lab: { L: 26.3, a: 45.8, b: 28.2 } },
"3022": { nombre: "114.3022 ROJO (POLIPRO)", hex: "#B70A0B", lab: { L: 38.4, a: 61.4, b: 48.4 } },
"3023": { nombre: "114.3023 ROJO (NYLON)", hex: "#A40508", lab: { L: 34, a: 57, b: 44.8 } },
"3029": { nombre: "114.3029 AZUL FLUORESCENTE", hex: "#0E94BE", lab: { L: 57.1, a: -17.2, b: -30.8 } },
"3032": { nombre: "114.3032 AZUL AQUA", hex: "#025B8F", lab: { L: 36.9, a: -2.4, b: -35 } },
"3034": { nombre: "114.3034 AZUL PASTEL CLARO", hex: "#1292C4", lab: { L: 56.8, a: -13.8, b: -34.7 } },
"3036P": { nombre: "114.3036 AZUL ULTRAMAR (POLIPRO)", hex: "#001A85", lab: { L: 17.6, a: 37.4, b: -60.1 } },
"3036N": { nombre: "114.3036 AZUL ULTRAMAR (NYLON)", hex: "#01279D", lab: { L: 23.3, a: 38.4, b: -65.6 } },
"3039": { nombre: "114.3039 VERDE FLUORESCENTE TRANSLUCIDO", hex: "#A7C4A1", lab: { L: 76.2, a: -16.4, b: 14.4 } },
"3042M": { nombre: "114.3042 VERDE FLUORESCENTE (MATE)", hex: "#329C54", lab: { L: 57.2, a: -46.4, b: 29.1 } },
"3042B": { nombre: "114.3042 VERDE FLUORESCENTE (BRILLOSO)", hex: "#39A95A", lab: { L: 61.6, a: -49, b: 31.7 } },
"3047": { nombre: "114.3047 VERDE AQUA OHP(USAR FONDO NEGRO)", hex: "#ACBABD", lab: { L: 74.5, a: -4.2, b: -3.2 } },
"3050P": { nombre: "114.3050 VERDE OBCURO (POLIPRO)", hex: "#1A4535", lab: { L: 26, a: -19.5, b: 5.2 } },
"3050N": { nombre: "114.3050 VERDE OBCURO (NYLON)", hex: "#1A4535", lab: { L: 26, a: -19.5, b: 5.2 } },
"3052": { nombre: "114.3052 AMARILLO FLUORESCENTE (PARA TPE)", hex: "#CCD046", lab: { L: 81, a: -18.2, b: 65 } },
"3053P": { nombre: "114.3053 AMARILLO FLUORESCENTE (POLIPRO)", hex: "#E2E965", lab: { L: 89.6, a: -19.4, b: 62 } },
"3053N": { nombre: "114.3053 AMARILLO FLUORESCENTE (NYLON)", hex: "#E6E128", lab: { L: 87.4, a: -16.9, b: 81 } },
"3055": { nombre: "114.3055 DORADO", hex: "#997B4A", lab: { L: 53.4, a: 5.2, b: 31 } },
"3057": { nombre: "114.3057 AMARILLO FLUORESCENTE TRANSLUCIDO", hex: "#DCD063", lab: { L: 82.5, a: -9.6, b: 54.7 } },
"3061": { nombre: "114.3061 NARANJA FLUORESCENTE", hex: "#FA5000", lab: { L: 58.1, a: 62.3, b: 68.7 } },
"3062": { nombre: "114.3062 NARANJA (POLIPRO)", hex: "#D74F03", lab: { L: 51.9, a: 50.9, b: 61.5 } },
"3063": { nombre: "114.3063 NARANJA (NYLON)", hex: "#CD2C05", lab: { L: 45.4, a: 60.6, b: 56.5 } },
"3065": { nombre: "114.3065 NARANJA FLUORESCENTE TRANSLUCIDO", hex: "#F76202", lab: { L: 60.4, a: 53.9, b: 69.2 } },
"3066": { nombre: "114.3066 NARANJA TRANSLUCIDO (SAN)", hex: "#C66509", lab: { L: 53.3, a: 33.9, b: 59.8 } },
"3068": { nombre: "114.3068 MORADO TRANSLUCIDO (SAN)", hex: "#162E99", lab: { L: 25, a: 33.3, b: -60.3 } },
"3070P": { nombre: "114.3070 CAFE CHOCOLATE (POLIPRO)", hex: "#2F1C1B", lab: { L: 12.7, a: 9.2, b: 4.5 } },
"3070N": { nombre: "114.3070 CAFE CHOCOLATE (NYLON)", hex: "#2F2123", lab: { L: 14.5, a: 7.1, b: 1.3 } },
"3072": { nombre: "114.3072 CAFE TRANSLUCIDO (POLIPRO)", hex: "#573944", lab: { L: 27.8, a: 15.2, b: -1.3 } },
"3075": { nombre: "114.3075 CAFE TRANSLUCIDO (SAN)", hex: "#482A31", lab: { L: 21, a: 15.1, b: 1.4 } },
"3076": { nombre: "114.3076 AZUL CLARO TRANSLUCIDO (SAN)", hex: "#0376AF", lab: { L: 47.1, a: -6.2, b: -37.9 } },
"3077": { nombre: "114.3077 AZUL (POLIPRO / TPE)", hex: "#072081", lab: { L: 18.6, a: 32.4, b: -55.9 } },
"3080": { nombre: "114.3080 MORADO ", hex: "#2D2D74", lab: { L: 22.6, a: 22.9, b: -41 } },
"3084": { nombre: "114.3084 AZUL REY TRANSLUCIDO (SAN)", hex: "#072A8E", lab: { L: 22.5, a: 30.9, b: -57.7 } },
"3088": { nombre: "114.3088 VERDE MANZANA TRANSLUCIDO (SAN)", hex: "#7FAE72", lab: { L: 66.5, a: -27.3, b: 25.9 } },
"3089": { nombre: "114.3089 VERDE BANDERA TRANSLUCIDO (SAN)", hex: "#0E594F", lab: { L: 33.6, a: -24.3, b: -0.4 } },
"3091": { nombre: "114.3091 MAGENTA", hex: "#A30837", lab: { L: 34.5, a: 57.8, b: 18.6 } },
"3093": { nombre: "114.3093 ROSA FLUORESCENTE", hex: "#F10966", lab: { L: 51.7, a: 79.1, b: 14.9 } },
"3098": { nombre: "114.3098 ROSA FLUORESCENTE TRANSLUCIDO", hex: "#E30871", lab: { L: 49.1, a: 76.8, b: 4.2 } },
"3100": { nombre: "114.3100 ROSA TRANSLUCIDO (SAN)", hex: "#E30871", lab: { L: 49.1, a: 76.8, b: 4.2 } },
"3101": { nombre: "114.3101 ROSA TPE Y PP", hex: "#F53CA2", lab: { L: 57.3, a: 75.9, b: -12.7 } },
"3109": { nombre: "114.3109 AMARILLO BOLIGRAFO", hex: "#E0830C", lab: { L: 63.4, a: 28.9, b: 67.8 } },
"3111": { nombre: "114.3111 VERDE MANZANA", hex: "#6DA235", lab: { L: 61.1, a: -35.5, b: 49.2 } },
"3114": { nombre: "114.3114 VERDE AQUA", hex: "#10838B", lab: { L: 49.7, a: -25.8, b: -12.7 } },
"3121": { nombre: "114.3121 NARANJA PASTEL", hex: "#D67D5C", lab: { L: 61.4, a: 31.3, b: 32.8 } },
"3122": { nombre: "114.3122 VERDE PASTEL (USAR FONDO NEGRO)", hex: "#A6B7B0", lab: { L: 73, a: -7.2, b: 1.6 } },
"3123": { nombre: "114.3123 ROSA PASTEL", hex: "#ED94B8", lab: { L: 71.3, a: 38.2, b: -4.5 } },
"3124": { nombre: "114.3124 AMARILLO PASTEL", hex: "#DCBF79", lab: { L: 78.4, a: 1.1, b: 39 } },
"3125": { nombre: "114.3125 MORADO PASTEL", hex: "#706DAA", lab: { L: 48.6, a: 15.9, b: -32.2 } },
"3126P": { nombre: "114.3126 AZUL PASTEL (POLIPRO)", hex: "#5E94C4", lab: { L: 59.5, a: -4.2, b: -30.3 } },
"3126S": { nombre: "114.3126 AZUL PASTEL (SAN)", hex: "#579AC4", lab: { L: 60.9, a: -9.2, b: -28.1 } },
"3127P": { nombre: "114.3127 MAGENTA VINO (POLIPRO)", hex: "#7C1335", lab: { L: 26.8, a: 45.2, b: 8.1 } },
"3127N": { nombre: "114.3127 MAGENTA VINO (NYLON)", hex: "#8F1B39", lab: { L: 31.6, a: 48.7, b: 12.7 } },
"3128": { nombre: "114.3128 AQUA PASTEL", hex: "#86BECB", lab: { L: 73.7, a: -14.9, b: -12.3 } },
"3129": { nombre: "114.3129 ROSA PASTEL", hex: "#B76372", lab: { L: 52.1, a: 35.4, b: 6.8 } },
"3130": { nombre: "114.3130 HUMO TRANSLUCIDO", hex: "#463F41", lab: { L: 27.4, a: 3.4, b: -0.1 } },
"3131": { nombre: "114.3131 ROJO TRANSLUCIDO (POLIPRO)", hex: "#A20B16", lab: { L: 33.9, a: 55.9, b: 38.2 } },
"3132": { nombre: "114.3132 AZUL REY TRASLUCIDO (POLIPRO)", hex: "#022B9C", lab: { L: 24.1, a: 35.5, b: -63.6 } },
"3133": { nombre: "114.3133 AZUL TRANSLUCIDO (POLIPRO)", hex: "#1B9ABE", lab: { L: 59, a: -19.7, b: -27.8 } },
"3135": { nombre: "114.3135 VERDE MANZANA TRANSLUCIDO (POLIPRO)", hex: "#99B998", lab: { L: 72.1, a: -17.3, b: 13.2 } },
"3136": { nombre: "114.3136 VERDE BANDERA TRANSLUCIDO (POLIPRO)", hex: "#19978B", lab: { L: 56.3, a: -34.8, b: -2.9 } },
"3137": { nombre: "114.3137 MORADO TRANSLUCIDO (POLIPRO)", hex: "#6158AB", lab: { L: 41.9, a: 25, b: -43.5 } },
"3138": { nombre: "114.3138 NARANJA TRANSLUCIDO (POLIPRO)", hex: "#D69203", lab: { L: 65.6, a: 16.5, b: 70 } },
"3139": { nombre: "114.3139 PURPURA TRANSLUCIDO (POLIPRO)", hex: "#3F1E61", lab: { L: 19.4, a: 30.5, b: -33.8 } },
"3140": { nombre: "114.3140 NARANJA PASTEL (SAN)", hex: "#CD7A56", lab: { L: 59.5, a: 28.9, b: 33.4 } },
"3141": { nombre: "114.3141 MORADO PASTEL (SAN)", hex: "#7379A2", lab: { L: 51.8, a: 7.5, b: -22.7 } },
"3142": { nombre: "114.3142 AMARILLO PASTEL (SAN)", hex: "#D3B46E", lab: { L: 74.6, a: 2.1, b: 39.7 } },
"3143": { nombre: "114.3143 CAFE PASTEL ", hex: "#8D7261", lab: { L: 50.2, a: 8, b: 13.4 } },
"3144": { nombre: "114.3144 VERDE PASTEL (SAN)", hex: "#AAC0B3", lab: { L: 75.8, a: -10, b: 4 } },
"3146": { nombre: "114.3146 COBRIZO", hex: "#9B5036", lab: { L: 42.7, a: 28.9, b: 29.2 } }
            };

            function rgbToHex(r, g, b) {
                const toHex = c => (c < 16 ? '0' : '') + c.toString(16);
                return `#${toHex(r)}${toHex(g)}${toHex(b)}`.toUpperCase();
            }

            function populateStandardColors() {
                 if (!standardColorSelect) { return; }
                standardColorSelect.innerHTML = '<option value="">-- Elija un estándar --</option>';
                for (const key in coloresEstandarAzor) {
                    const option = document.createElement('option');
                    option.value = key;
                    option.textContent = coloresEstandarAzor[key].nombre;
                    standardColorSelect.appendChild(option);
                }
            }

            // Esta función ahora solo habilita los controles si la cámara está "lista"
            function setAppControlsActive(isActive) {
                isCameraReady = isActive;
                if (captureButton) captureButton.disabled = !isActive;
                if (selectImageBtn) selectImageBtn.disabled = !isActive;
                if (standardColorSelect) standardColorSelect.disabled = !isActive;

                if(isActive) {
                    if(instructionTextEl) instructionTextEl.textContent = "Cámara lista. Capture una imagen y dibuje un recuadro para seleccionar el área de color.";
                    if(instructionTextEl) instructionTextEl.style.color = '#212529'; // Color normal
                    if(mainInstructionTextEl) mainInstructionTextEl.textContent = "Cámara lista y ajustes aplicados. Proceda a capturar la imagen.";
                    if(mainInstructionTextEl) mainInstructionTextEl.style.color = '#28a745'; // Verde para éxito
                    if (capturePrompt) capturePrompt.textContent = "Cámara lista. Capture una imagen para analizar.";
                } else {
                    if(instructionTextEl) instructionTextEl.textContent = "Cargando cámara y aplicando ajustes iniciales...";
                    if(instructionTextEl) instructionTextEl.style.color = '#007bff';
                    if(mainInstructionTextEl) mainInstructionTextEl.textContent = "Cargando cámara con ajustes predefinidos.";
                    if(mainInstructionTextEl) mainInstructionTextEl.style.color = '#007bff';
                    if (capturePrompt) capturePrompt.textContent = "Activando cámara y aplicando ajustes...";
                }
            }
            
            async function startWebcam() {
                if (!videoElement || !captureCanvas || !displayCanvas || !webcamLoadingPrompt || !capturePrompt || !displayCtx || !captureCtx) {
                    if (webcamLoadingPrompt) webcamLoadingPrompt.textContent = "Error: Elementos de UI no encontrados.";
                    return;
                }
                setAppControlsActive(false); // Iniciar con controles deshabilitados
                videoElement.style.display = 'block';
                const webcamContainer = document.getElementById('color-webcam-container');
                if (webcamContainer) webcamContainer.style.minHeight = ''; 
                webcamLoadingPrompt.style.display = 'block';
                capturePrompt.textContent = "Activando cámara...";
                capturePrompt.style.display = 'block'; 
                if (displayCtx) displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);

                try {
                    if (stream) { 
                        stream.getTracks().forEach(track => track.stop());
                        stream = null; 
                        videoTrack = null;
                    }
                    const constraints = { 
                        video: { 
                            facingMode: "environment", 
                            width: { ideal: 640 }, 
                            height: { ideal: 480 }
                        } 
                    };
                    stream = await navigator.mediaDevices.getUserMedia(constraints);
                    videoElement.srcObject = stream;
                    videoTrack = stream.getVideoTracks()[0]; 
                    cameraCapabilities = videoTrack.getCapabilities ? videoTrack.getCapabilities() : {};
                    
                    await new Promise((resolve, reject) => {
                        let resolved = false; let loadAttempts = 0; const maxLoadAttempts = 5; 
                        function checkVideoDimensions() {
                            if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                                if (!resolved) {
                                    captureCanvas.width = videoElement.videoWidth;
                                    captureCanvas.height = videoElement.videoHeight;
                                    // calibrationHelperCanvas ya no se usa para calibración, pero se mantiene si se necesita para otros fines
                                    if (calibrationHelperCanvas) { 
                                        calibrationHelperCanvas.width = videoElement.videoWidth;
                                        calibrationHelperCanvas.height = videoElement.videoHeight;
                                    }
                                    const webcamContainerEl = document.getElementById('color-webcam-container');
                                    const aspectRatio = videoElement.videoWidth / videoElement.videoHeight;
                                    let dCanvasWidth = (webcamContainerEl && webcamContainerEl.clientWidth > 0) ? webcamContainerEl.clientWidth - 2 : 300; 
                                    let dCanvasHeight = dCanvasWidth / aspectRatio;
                                    if (dCanvasHeight > 280) { dCanvasHeight = 280; dCanvasWidth = dCanvasHeight * aspectRatio; }
                                    displayCanvas.width = dCanvasWidth; displayCanvas.height = dCanvasHeight;
                                    resolved = true; resolve();
                                }
                            } else {
                                loadAttempts++;
                                if (loadAttempts < maxLoadAttempts && !resolved) { setTimeout(checkVideoDimensions, 500); } 
                                else if (!resolved) { reject(new Error("Dimensiones del video siguen siendo 0.")); }
                            }
                        }
                        videoElement.onloadedmetadata = checkVideoDimensions; videoElement.oncanplay = checkVideoDimensions; 
                        videoElement.onerror = (e) => { if (!resolved) reject(new Error("Error al cargar metadata/video: " + e)); };
                        setTimeout(() => { if (!resolved) reject(new Error("Timeout esperando metadata/video.")); }, 4000); 
                    });
                    
                    if (webcamLoadingPrompt) webcamLoadingPrompt.style.display = 'none';
                    imageIsCaptured = false; pickedColorRGB = null; 
                    
                    // Aplicar ajustes fijos de la cámara
                    await applyFixedCameraSettings();
                    setAppControlsActive(true); // Habilitar controles una vez que los ajustes se intentan aplicar
                    checkEnableCompareButton();

                } catch (err) {
                    console.error("Validador Color: Error al acceder/configurar webcam: ", err);
                    if (webcamLoadingPrompt) webcamLoadingPrompt.style.display = 'none';
                    if (capturePrompt) capturePrompt.textContent = "Error webcam: " + (err.message ? err.message.substring(0, 70) : "Desconocido") + "... Por favor, recargue la página y otorge permisos.";
                    setAppControlsActive(false); // Mantener deshabilitado si falla
                }
            }

            async function applyCameraSetting(settingName, value) {
                if (!videoTrack || !videoTrack.applyConstraints) {
                    console.warn(`applyConstraints no soportado o pista de video no disponible para ${settingName}.`);
                    return false;
                }
                const constraint = {};
                constraint[settingName] = value;

                try {
                    console.log(`Aplicando ajuste: ${settingName} = ${value}`);
                    await videoTrack.applyConstraints({ advanced: [constraint] });
                    console.log(`Ajuste ${settingName} aplicado.`);
                    return true;
                } catch (err) {
                    console.error(`Error al aplicar ${settingName} = ${value}: `, err);
                    return false;
                }
            }

            // Función para aplicar los valores fijos
            async function applyFixedCameraSettings() {
                console.log("Aplicando ajustes de cámara fijos...");
                // Brillo: 120
                if (cameraCapabilities.brightness) {
                    await applyCameraSetting('brightness', 120);
                }
                // Contraste: 143
                if (cameraCapabilities.contrast) {
                    await applyCameraSetting('contrast', 143);
                }
                // Saturación: 140
                if (cameraCapabilities.saturation) {
                    await applyCameraSetting('saturation', 140);
                }
                // Nitidez: 135
                if (cameraCapabilities.sharpness) {
                    await applyCameraSetting('sharpness', 135);
                }

                // Exposición y Temperatura de color
                // Para exposición y balance de blancos, a menudo es necesario establecer el modo a 'manual' primero.
                // Sin embargo, si la cámara no soporta 'manual', intentar aplicar un valor fijo en 'continuous' podría no tener efecto.
                // Aquí se intentará establecer el modo a manual si es posible y luego los valores.

                // Tiempo de Exposición: 78.1250000 (log2 s)
                if (cameraCapabilities.exposureMode && cameraCapabilities.exposureMode.includes('manual')) {
                    await applyCameraSetting('exposureMode', 'manual');
                    if (cameraCapabilities.exposureTime) {
                         // El valor de exposureTime es en segundos, no log2 s.
                         // 78.125 es un valor demasiado alto para exposureTime en segundos. 
                         // Si el valor original era en log2 segundos, 2^x = 78.125 significa x = log2(78.125) = ~6.28.
                         // Sin embargo, si 78.1250000 es el valor literal que se debe usar, lo aplicamos directamente.
                         // Asumiendo que 78.125 es el valor deseado para exposureTime (en segundos o la unidad que la cámara espera).
                        await applyCameraSetting('exposureTime', 78.125); 
                    } else {
                        console.warn("La cámara no soporta el control de exposureTime.");
                    }
                } else {
                    console.warn("La cámara no soporta el modo de exposición manual. Los ajustes de tiempo de exposición pueden no aplicarse.");
                }

                // Temperatura de Color: 6130 K
                if (cameraCapabilities.whiteBalanceMode && cameraCapabilities.whiteBalanceMode.includes('manual')) {
                    await applyCameraSetting('whiteBalanceMode', 'manual');
                    if (cameraCapabilities.colorTemperature) {
                        await applyCameraSetting('colorTemperature', 6130);
                    } else {
                        console.warn("La cámara no soporta el control de colorTemperature.");
                    }
                } else {
                    console.warn("La cámara no soporta el modo de balance de blancos manual. Los ajustes de temperatura de color pueden no aplicarse.");
                }
                console.log("Intentos de aplicar ajustes fijos completados.");
            }
            
            function resetUIForNewCapture() {
                if (capturePrompt) capturePrompt.style.display = 'none'; 
                imageIsCaptured = true; pickedColorRGB = null; 
                if (compareButton) compareButton.disabled = true; 
                if(capturedColorDisplay) capturedColorDisplay.style.backgroundColor = 'transparent';
                if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Dibuje un área en la imagen';
                if(deltaEValueEl) deltaEValueEl.textContent = '-';
                if(toleranceStatusEl) {
                    toleranceStatusEl.textContent = '-';
                    toleranceStatusEl.className = 'tolerance-status-text';
                }
                if(toleranceBar) { 
                    toleranceBar.style.width = '0%'; 
                    toleranceBar.className = 'tolerance-bar-fill';
                }
                if (instructionTextEl) {
                     instructionTextEl.textContent = "Dibuje un recuadro en la imagen para seleccionar el área de color.";
                     instructionTextEl.style.color = '#212529'; // Color normal
                }
                if(colorResultNoteEl) colorResultNoteEl.textContent = '';
                checkEnableCompareButton();
            }

            if (captureButton) {
                captureButton.addEventListener('click', async () => {
                    if (!isCameraReady) {
                        alert("La cámara aún no está lista o los ajustes iniciales no se han aplicado completamente. Por favor, espere o recargue.");
                        return;
                    }
                    // ... resto de la lógica de captura ...
                    let cameraRestarted = false;
                    // Simplificado: Si la cámara no está activa, intentamos reiniciarla y aplicar ajustes
                    if (!stream || !videoElement.srcObject || videoElement.paused || videoElement.ended || !videoTrack) {
                        videoElement.style.display = 'block';
                        const webcamContainer = document.getElementById('color-webcam-container');
                        if (webcamContainer) webcamContainer.style.minHeight = ''; 
                        if (webcamLoadingPrompt) webcamLoadingPrompt.style.display = 'block';
                        if (capturePrompt) capturePrompt.textContent = "Activando cámara...";

                        await startWebcam(); 
                        if (!stream || !videoElement.srcObject || videoElement.paused || videoElement.ended || !videoTrack) {
                             if (capturePrompt) capturePrompt.textContent = "No se pudo activar la cámara. Revise permisos o recargue.";
                             if (webcamLoadingPrompt) webcamLoadingPrompt.style.display = 'none';
                            return;
                        }
                        if (!isCameraReady) { // Re-chequear después de posible reinicio de cámara
                            alert("La cámara se reinició pero los ajustes no se aplicaron. Por favor, recargue la página.");
                            return;
                        }
                        cameraRestarted = true;
                        await new Promise(resolve => setTimeout(resolve, 200)); 
                    }

                    if (videoElement.videoWidth > 0 && videoElement.videoHeight > 0) {
                        if (captureCanvas.width !== videoElement.videoWidth || captureCanvas.height !== videoElement.videoHeight) {
                            captureCanvas.width = videoElement.videoWidth;
                            captureCanvas.height = videoElement.videoHeight;
                        }
                    } else {
                        console.warn("Dimensiones video no disponibles al capturar, usando fallback.");
                        captureCanvas.width = 640; captureCanvas.height = 480;
                    }

                    if (!captureCtx) {
                        console.error("Contexto captureCanvas no disponible al capturar.");
                        if (capturePrompt) capturePrompt.textContent = "Error: Contexto de captura no disponible.";
                        return;
                    }
                    captureCtx.drawImage(videoElement, 0, 0, captureCanvas.width, captureCanvas.height);

                    const parentWidth = displayCanvas.parentElement ? displayCanvas.parentElement.clientWidth : 300;
                    const aspectRatio = (captureCanvas.height > 0) ? (captureCanvas.width / captureCanvas.height) : (16/9); 
                    let dCanvasWidth = parentWidth > 0 ? parentWidth - 2 : 300;
                    let dCanvasHeight = dCanvasWidth / aspectRatio;
                    if (dCanvasHeight > 280) { dCanvasHeight = 280; dCanvasWidth = dCanvasHeight * aspectRatio; }
                    displayCanvas.width = dCanvasWidth; displayCanvas.height = dCanvasHeight;

                    if (displayCtx) {
                        displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height); 
                        displayCtx.drawImage(captureCanvas, 0, 0, displayCanvas.width, displayCanvas.height);
                    }
                    
                    resetUIForNewCapture();
                    
                    if (capturePrompt) {
                        capturePrompt.textContent = "Imagen capturada. Dibuje el área.";
                        capturePrompt.style.display = 'block';
                    }
                    if (webcamLoadingPrompt) webcamLoadingPrompt.style.display = 'none';
                });
            }

            if (selectImageBtn && fileInput) {
                selectImageBtn.addEventListener('click', () => { 
                     if (!isCameraReady) {
                        alert("La cámara aún no está lista. Espere a que se apliquen los ajustes predefinidos antes de seleccionar una imagen.");
                        return;
                    }
                    fileInput.click(); 
                });
                fileInput.addEventListener('change', (event) => {
                    const file = event.target.files[0];
                    if (file && file.type.startsWith('image/')) {
                        const reader = new FileReader();
                        reader.onload = (e) => {
                            const img = new Image();
                            img.onload = () => {
                                // Detener webcam si está activa al cargar imagen
                                if (stream) {
                                    stream.getTracks().forEach(track => track.stop());
                                    stream = null;
                                    videoTrack = null;
                                    videoElement.srcObject = null;
                                }
                                videoElement.style.display = 'none';
                                if (webcamLoadingPrompt) webcamLoadingPrompt.style.display = 'none';
                                const webcamContainer = document.getElementById('color-webcam-container');
                                if (webcamContainer) webcamContainer.style.minHeight = 'auto';


                                if (captureCanvas.width !== img.width || captureCanvas.height !== img.height) {
                                    captureCanvas.width = img.width;
                                    captureCanvas.height = img.height;
                                }
                                if (!captureCtx) {
                                    console.error("Contexto captureCanvas no disponible para imagen cargada.");
                                    if (capturePrompt) capturePrompt.textContent = "Error: Contexto de imagen no disponible.";
                                    return;
                                }
                                captureCtx.drawImage(img, 0, 0, captureCanvas.width, captureCanvas.height);

                                const parentWidth = displayCanvas.parentElement ? displayCanvas.parentElement.clientWidth : 300;
                                const aspectRatio = (captureCanvas.height > 0) ? (captureCanvas.width / captureCanvas.height) : (16/9);
                                let dCanvasWidth = parentWidth > 0 ? parentWidth - 2 : 300;
                                let dCanvasHeight = dCanvasWidth / aspectRatio;
                                if (dCanvasHeight > 280) { 
                                    dCanvasHeight = 280;
                                    dCanvasWidth = dCanvasHeight * aspectRatio;
                                }
                                displayCanvas.width = dCanvasWidth;
                                displayCanvas.height = dCanvasHeight;

                                if (displayCtx) {
                                    displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                                    displayCtx.drawImage(captureCanvas, 0, 0, displayCanvas.width, displayCanvas.height);
                                }

                                resetUIForNewCapture(); 
                                if (capturePrompt) {
                                     capturePrompt.textContent = "Imagen cargada desde archivo.";
                                     capturePrompt.style.display = 'block';
                                }
                                fileInput.value = null; 
                            };
                            img.onerror = () => {
                                if (capturePrompt) capturePrompt.textContent = "Error al cargar la imagen seleccionada.";
                                console.error("Error al cargar la imagen seleccionada en el elemento Image.");
                                fileInput.value = null;
                            };
                            img.src = e.target.result;
                        };
                        reader.onerror = () => {
                            if (capturePrompt) capturePrompt.textContent = "Error al leer el archivo de imagen.";
                            console.error("Error al leer el archivo con FileReader.");
                            fileInput.value = null;
                        };
                        reader.readAsDataURL(file);
                    } else if (file) {
                        if (capturePrompt) capturePrompt.textContent = "Por favor, seleccione un archivo de imagen válido (PNG, JPG, etc.).";
                        console.warn("Archivo seleccionado no es una imagen:", file.type);
                        fileInput.value = null;
                    }
                });
            }

            function checkEnableCompareButton() {
                 if (compareButton) {
                    const standardSelected = standardColorSelect && standardColorSelect.value !== "";
                    // Habilitar solo si la cámara está lista (o se cargó una imagen) Y hay color picado Y hay estándar seleccionado
                    compareButton.disabled = !(isCameraReady && pickedColorRGB && standardSelected && currentStandardColorData);
                }
            }

            if (displayCanvas && displayCtx && captureCtx) {
                 displayCanvas.addEventListener('mousedown', (event) => {
                    if (!isCameraReady || !imageIsCaptured) return;  // No permitir dibujar si la cámara no está lista o no hay imagen
                    isDrawingSelection = true; const rect = displayCanvas.getBoundingClientRect();
                    selectionRect.startX = event.clientX - rect.left; selectionRect.startY = event.clientY - rect.top;
                    selectionRect.currentX = selectionRect.startX; selectionRect.currentY = selectionRect.startY;
                    selectionRect.width = 0; selectionRect.height = 0;
                    pickedColorRGB = null; 
                    if(capturedColorDisplay) capturedColorDisplay.style.backgroundColor = 'transparent';
                    if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Dibujando área...';
                    checkEnableCompareButton(); 
                });

                displayCanvas.addEventListener('mousemove', (event) => {
                    if (!isCameraReady ||!imageIsCaptured || !isDrawingSelection) return;
                    const rect = displayCanvas.getBoundingClientRect();
                    selectionRect.currentX = event.clientX - rect.left; selectionRect.currentY = event.clientY - rect.top;
                    selectionRect.width = selectionRect.currentX - selectionRect.startX;
                    selectionRect.height = selectionRect.currentY - selectionRect.startY;
                    if (captureCanvas && captureCanvas.width > 0 && captureCanvas.height > 0 && displayCtx) { 
                        displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                        displayCtx.drawImage(captureCanvas, 0, 0, displayCanvas.width, displayCanvas.height);
                        displayCtx.strokeStyle = 'rgba(0, 123, 255, 0.8)'; displayCtx.lineWidth = 2;
                        displayCtx.strokeRect(selectionRect.startX, selectionRect.startY, selectionRect.width, selectionRect.height);
                    }
                });

                displayCanvas.addEventListener('mouseup', () => {
                    if (!isCameraReady || !imageIsCaptured || !isDrawingSelection) { isDrawingSelection = false; return; }
                    isDrawingSelection = false;
                    let finalRectX = Math.min(selectionRect.startX, selectionRect.currentX);
                    let finalRectY = Math.min(selectionRect.startY, selectionRect.currentY);
                    let finalRectWidth = Math.abs(selectionRect.width);
                    let finalRectHeight = Math.abs(selectionRect.height);
                    
                    if (!(displayCtx && captureCanvas && captureCanvas.width > 0 && captureCanvas.height > 0 && captureCtx)) {
                        if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Error: Imagen base no disp.';
                        pickedColorRGB = null; checkEnableCompareButton(); return;
                    }
                    displayCtx.clearRect(0, 0, displayCanvas.width, displayCanvas.height);
                    displayCtx.drawImage(captureCanvas, 0, 0, displayCanvas.width, displayCanvas.height);
                    if (finalRectWidth < 1 || finalRectHeight < 1) { 
                        if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Área muy pequeña.';
                        pickedColorRGB = null; checkEnableCompareButton(); return;
                    }
                    if (displayCanvas.width === 0 || displayCanvas.height === 0) {
                        if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Error: Display inválido.';
                        pickedColorRGB = null; checkEnableCompareButton(); return;
                    }
                    const scaleX = captureCanvas.width / displayCanvas.width; const scaleY = captureCanvas.height / displayCanvas.height;
                    let originalX = Math.floor(finalRectX * scaleX); let originalY = Math.floor(finalRectY * scaleY);
                    let originalWidth = Math.floor(finalRectWidth * scaleX); let originalHeight = Math.floor(finalRectHeight * scaleY);
                    originalX = Math.max(0, Math.min(originalX, captureCanvas.width - 1));
                    originalY = Math.max(0, Math.min(originalY, captureCanvas.height - 1));
                    originalWidth = Math.max(1, Math.min(originalWidth, captureCanvas.width - originalX)); 
                    originalHeight = Math.max(1, Math.min(originalHeight, captureCanvas.height - originalY));
                    if (originalWidth <= 0 || originalHeight <= 0) {
                        if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Error: Área cálculo inválida.';
                        pickedColorRGB = null; checkEnableCompareButton(); return;
                    }
                    try {
                        const imageData = captureCtx.getImageData(originalX, originalY, originalWidth, originalHeight);
                        const data = imageData.data; let sumR = 0, sumG = 0, sumB = 0; let pixelCount = 0;
                        for (let i = 0; i < data.length; i += 4) {
                            sumR += data[i]; sumG += data[i+1]; sumB += data[i+2]; pixelCount++;
                        }
                        if (pixelCount > 0) {
                            pickedColorRGB = { r: Math.round(sumR / pixelCount), g: Math.round(sumG / pixelCount), b: Math.round(sumB / pixelCount) };
                            const hexPicked = rgbToHex(pickedColorRGB.r, pickedColorRGB.g, pickedColorRGB.b);
                            let labCapturedText = 'N/A'; let labConversionOk = false;

                            if (typeof window.chroma !== 'undefined') { 
                                try {
                                    const labArr = window.chroma(pickedColorRGB.r, pickedColorRGB.g, pickedColorRGB.b).lab();
                                    labCapturedText = `${labArr[0].toFixed(1)}, ${labArr[1].toFixed(1)}, ${labArr[2].toFixed(1)}`;
                                    labConversionOk = true;
                                } catch (chromaError) {
                                    console.error("Error al usar chroma-js para convertir RGB a LAB:", chromaError);
                                    if(capturedColorValuesEl) capturedColorValuesEl.textContent = `HEX: ${hexPicked} | LAB: Error chroma.js`;
                                }
                            } else {
                                console.warn("Librería 'chroma-js' (window.chroma) NO está definida al procesar la muestra.");
                                if(capturedColorValuesEl) capturedColorValuesEl.textContent = `HEX: ${hexPicked} | LAB: Error lib. conversión`;
                            }

                            if (capturedColorDisplay) capturedColorDisplay.style.backgroundColor = hexPicked;
                            if (labConversionOk) { 
                                if(capturedColorValuesEl) capturedColorValuesEl.textContent = `HEX: ${hexPicked} | LAB: ${labCapturedText}`;
                            }
                            if (instructionTextEl) instructionTextEl.textContent = "Área seleccionada. Elija un estándar y compare."; 
                            displayCtx.strokeStyle = 'rgba(40, 167, 69, 0.9)'; displayCtx.lineWidth = 2;
                            displayCtx.strokeRect(finalRectX, finalRectY, finalRectWidth, finalRectHeight); 
                        } else {
                             if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'No se pudo promediar (0px).';
                             pickedColorRGB = null;
                        }
                    } catch (e) {
                        console.error("Error al procesar datos del área (catch):", e); 
                        if(capturedColorValuesEl) capturedColorValuesEl.textContent = 'Error procesar área.';
                        pickedColorRGB = null;
                    }
                    checkEnableCompareButton();
                });
            } else {
                console.error("Validador Color: Canvas de dibujo no encontrado/inicializado.");
            }
            
            if (standardColorSelect) {
                standardColorSelect.addEventListener('change', () => {
                     const selectedKey = standardColorSelect.value;
                    if (selectedKey && coloresEstandarAzor[selectedKey]) {
                        currentStandardColorData = coloresEstandarAzor[selectedKey];
                        if(standardColorDisplay) standardColorDisplay.style.backgroundColor = currentStandardColorData.hex;
                        if(standardColorValuesEl) {
                            standardColorValuesEl.textContent = `HEX: ${currentStandardColorData.hex.toUpperCase()} | LAB: ${currentStandardColorData.lab.L.toFixed(1)}, ${currentStandardColorData.lab.a.toFixed(1)}, ${currentStandardColorData.lab.b.toFixed(1)}`;
                        }
                    } else {
                        currentStandardColorData = null;
                        if(standardColorDisplay) standardColorDisplay.style.backgroundColor = 'transparent';
                        if(standardColorValuesEl) standardColorValuesEl.textContent = '-';
                    }
                    checkEnableCompareButton(); 
                });
            }

            if (compareButton) {
                compareButton.addEventListener('click', () => {
                     if (!pickedColorRGB || !currentStandardColorData) {
                        if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Faltan datos.';
                        return;
                    }
                     if (!isCameraReady) { // Chequeo extra, aunque el botón debería estar deshabilitado si no está ready
                        alert("La aplicación no está lista. Por favor, espere o recargue.");
                        return;
                    }
                    
                    let labSampleFromChroma; 
                    let conversionOkForComparison = false;

                    if (typeof window.chroma !== 'undefined') { 
                        try {
                            const labChromaArray = window.chroma(pickedColorRGB.r, pickedColorRGB.g, pickedColorRGB.b).lab();
                            labSampleFromChroma = { 
                                L: parseFloat(labChromaArray[0]), 
                                a: parseFloat(labChromaArray[1]), 
                                b: parseFloat(labChromaArray[2]) 
                            };
                            if (isNaN(labSampleFromChroma.L) || isNaN(labSampleFromChroma.a) || isNaN(labSampleFromChroma.b)) {
                                console.error("Error de conversión a LAB con Chroma.js: uno de los valores es NaN.", labChromaArray);
                                if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Conversión LAB (NaN)';
                                if (toleranceStatusEl) {
                                    toleranceStatusEl.textContent = 'Error Conversión';
                                    toleranceStatusEl.className = 'tolerance-status-text status-danger';
                                }
                                return;
                            }
                            conversionOkForComparison = true;
                        } catch (chromaError) {
                             console.error("Error al usar chroma-js para comparación:", chromaError);
                             if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Lib. Conversión';
                             if (toleranceStatusEl) {
                                toleranceStatusEl.textContent = 'Error Conversión';
                                toleranceStatusEl.className = 'tolerance-status-text status-danger';
                             }
                             return;
                        }
                    } else {
                        console.error("Librería 'chroma-js' (window.chroma) NO está definida para comparación.");
                        if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Lib. Conversión';
                        if (toleranceStatusEl) {
                            toleranceStatusEl.textContent = 'Error Librería';
                            toleranceStatusEl.className = 'tolerance-status-text status-danger';
                        }
                        return;
                    }

                    const labStandardOriginal = currentStandardColorData.lab;
                     if (!labStandardOriginal || typeof labStandardOriginal.L !== 'number' || typeof labStandardOriginal.a !== 'number' || typeof labStandardOriginal.b !== 'number') {
                         console.error("Datos LAB del color estándar son inválidos o no son números:", labStandardOriginal);
                         if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Estándar LAB inv.';
                         if (toleranceStatusEl) {
                            toleranceStatusEl.textContent = 'Error Estándar';
                            toleranceStatusEl.className = 'tolerance-status-text status-danger';
                         }
                         return;
                    }

                    const labForDeltaESample = { L: labSampleFromChroma.L, A: labSampleFromChroma.a, B: labSampleFromChroma.b };
                    const labForDeltaEStandard = { L: labStandardOriginal.L, A: labStandardOriginal.a, B: labStandardOriginal.b };

                    if (typeof window.DeltaE === 'undefined' || (window.DeltaE && typeof window.DeltaE.getDeltaE00 !== 'function')) {
                        console.error("Error formal: Librería 'DeltaE' no disponible o función getDeltaE00 no encontrada.");
                        if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Librería Delta E.';
                        if (toleranceStatusEl) {
                            toleranceStatusEl.textContent = 'Error Librería ΔE';
                            toleranceStatusEl.className = 'tolerance-status-text status-danger';
                        }
                        return;
                    }
                    
                    let deltaE;
                    try {
                        deltaE = window.DeltaE.getDeltaE00(labForDeltaESample, labForDeltaEStandard);
                    } catch (deltaError) {
                        console.error("Error al calcular Delta E con la librería:", deltaError);
                        if (deltaEValueEl) deltaEValueEl.textContent = 'Error: Cálculo Delta E.';
                        if (toleranceStatusEl) {
                            toleranceStatusEl.textContent = 'Error Cálculo ΔE';
                            toleranceStatusEl.className = 'tolerance-status-text status-danger';
                        }
                        return;
                    }
                    
                    if (isNaN(deltaE)) {
                        console.error("Error: El cálculo de DeltaE resultó en NaN.");
                        console.log("Valores que entraron a getDeltaE00: Sample (L,A,B):", labForDeltaESample, "Standard (L,A,B):", labForDeltaEStandard);
                        if (deltaEValueEl) deltaEValueEl.textContent = 'NaN (Error Cálculo)';
                        if (toleranceStatusEl) {
                            toleranceStatusEl.textContent = 'Error en Cálculo (NaN)';
                            toleranceStatusEl.className = 'tolerance-status-text status-danger';
                        }
                        if (toleranceBar) {
                            toleranceBar.style.width = '0%'; 
                            toleranceBar.className = 'tolerance-bar-fill status-danger';
                        }
                        return; 
                    }

                    if (deltaEValueEl) deltaEValueEl.textContent = deltaE.toFixed(2);
                    
                    let statusText = ''; 
                    let barClass = 'tolerance-bar-fill'; 
                    let statusClass = ''; 
                    let barWidthPercentage = 0;
                    const maxDeltaEForBar = 10; const umbralExcelente = 1.5; const umbralAceptable = 3.5; 

                    if (deltaE <= umbralExcelente) {
                        statusText = 'Aprobado (Excelente)'; statusClass = 'status-ok';
                        barWidthPercentage = (deltaE / umbralExcelente) * (100 / 3);
                    } else if (deltaE <= umbralAceptable) {
                        statusText = 'Aprobado (Aceptable)'; statusClass = 'status-warning';
                        barWidthPercentage = (100 / 3) + ((deltaE - umbralExcelente) / (umbralAceptable - umbralExcelente)) * (100 / 3);
                    } else {
                        statusText = 'Rechazado (Fuera de Tolerancia)'; statusClass = 'status-danger';
                        if (deltaE <= maxDeltaEForBar) {
                           barWidthPercentage = (200 / 3) + ((deltaE - umbralAceptable) / (maxDeltaEForBar - umbralAceptable)) * (100 / 3);
                        } else { barWidthPercentage = 100; }
                    }
                    barWidthPercentage = Math.min(100, Math.max(0, barWidthPercentage)); 

                    if (toleranceStatusEl) {
                        toleranceStatusEl.textContent = statusText;
                        toleranceStatusEl.className = 'tolerance-status-text'; 
                        toleranceStatusEl.classList.add(statusClass); 
                    }
                    
                    if (toleranceBar) { 
                        toleranceBar.style.width = `${barWidthPercentage}%`;
                        toleranceBar.className = `tolerance-bar-fill ${statusClass}`; 
                    }

                    if (colorResultNoteEl) {
                        let note = `Un valor ΔE*₀₀ de ${deltaE.toFixed(2)} indica la diferencia perceptual. `;
                        if (deltaE <= 1.0) note += "Generalmente imperceptible."; else if (deltaE <= 2.0) note += "Diferencia muy pequeña.";
                        else if (deltaE <= 5.0) note += "Diferencia perceptible."; else if (deltaE <= 10.0) note += "Claramente perceptible.";
                        else note += "Diferencia muy grande.";
                        colorResultNoteEl.textContent = note;
                    }
                });
            }
            populateStandardColors();
            startWebcam(); 
        });
    </script>
</body>
</html>
